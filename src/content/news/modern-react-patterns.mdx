# Modern React Patterns for 2024

React continues to evolve, and with it, the patterns and best practices for building robust applications. Let's explore the modern patterns that are shaping React development in 2024.

## Server Components

React Server Components represent a paradigm shift in how we think about rendering:

```jsx
// Server Component
async function BlogPost({ id }) {
  const post = await fetchPost(id); // Runs on server
  
  return (
    <article>
      <h1>{post.title}</h1>
      <Content post={post} />
    </article>
  );
}

// Client Component
'use client';
function Content({ post }) {
  const [likes, setLikes] = useState(post.likes);
  
  return (
    <div>
      <p>{post.content}</p>
      <button onClick={() => setLikes(l => l + 1)}>
        üëç {likes}
      </button>
    </div>
  );
}
```

## Concurrent Features

React 18's concurrent features are becoming mainstream:

### Suspense for Data Fetching

```jsx
function UserProfile({ userId }) {
  return (
    <Suspense fallback={<ProfileSkeleton />}>
      <UserData userId={userId} />
    </Suspense>
  );
}

function UserData({ userId }) {
  const user = use(fetchUser(userId)); // use() hook
  return <div>{user.name}</div>;
}
```

### Transitions

```jsx
function SearchResults() {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [isPending, startTransition] = useTransition();

  const handleSearch = (newQuery) => {
    setQuery(newQuery);
    startTransition(() => {
      // Non-urgent update
      setResults(searchData(newQuery));
    });
  };

  return (
    <div>
      <input onChange={(e) => handleSearch(e.target.value)} />
      {isPending && <div>Searching...</div>}
      <ResultsList results={results} />
    </div>
  );
}
```

## Custom Hooks Patterns

Modern custom hooks follow these patterns:

### Data Fetching Hook

```jsx
function useApi(url, options = {}) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const controller = new AbortController();
    
    async function fetchData() {
      try {
        setLoading(true);
        const response = await fetch(url, {
          ...options,
          signal: controller.signal
        });
        const result = await response.json();
        setData(result);
      } catch (err) {
        if (err.name !== 'AbortError') {
          setError(err);
        }
      } finally {
        setLoading(false);
      }
    }

    fetchData();
    return () => controller.abort();
  }, [url]);

  return { data, loading, error };
}
```

## State Management Patterns

### Zustand for Simple State

```jsx
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
  decrement: () => set((state) => ({ count: state.count - 1 })),
}));

function Counter() {
  const { count, increment, decrement } = useStore();
  return (
    <div>
      <span>{count}</span>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
    </div>
  );
}
```

## Component Composition

Modern React favors composition over inheritance:

```jsx
// Compound Components Pattern
function Card({ children }) {
  return <div className="card">{children}</div>;
}

Card.Header = ({ children }) => <div className="card-header">{children}</div>;
Card.Body = ({ children }) => <div className="card-body">{children}</div>;
Card.Footer = ({ children }) => <div className="card-footer">{children}</div>;

// Usage
function ProfileCard() {
  return (
    <Card>
      <Card.Header>
        <h2>John Doe</h2>
      </Card.Header>
      <Card.Body>
        <p>Software Developer</p>
      </Card.Body>
      <Card.Footer>
        <button>Contact</button>
      </Card.Footer>
    </Card>
  );
}
```

## Performance Optimization

### React.memo with Comparison Function

```jsx
const ExpensiveComponent = React.memo(({ data, onUpdate }) => {
  return (
    <div>
      {data.map(item => <Item key={item.id} item={item} />)}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison
  return prevProps.data.length === nextProps.data.length &&
         prevProps.data.every((item, index) => 
           item.id === nextProps.data[index].id
         );
});
```

## Testing Patterns

Modern testing focuses on user behavior:

```jsx
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('user can increment counter', async () => {
  const user = userEvent.setup();
  render(<Counter />);
  
  const button = screen.getByRole('button', { name: /increment/i });
  await user.click(button);
  
  expect(screen.getByText('1')).toBeInTheDocument();
});
```

## Conclusion

React in 2024 emphasizes server-side rendering, concurrent features, and improved developer experience. By adopting these patterns, developers can build more performant, maintainable, and user-friendly applications.